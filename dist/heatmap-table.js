import { S as SvelteComponent, i as init, s as safe_not_equal, C as handle_promise, e as element, a as space, b as attr, c as insert, d as append, D as update_await_block_branch, m as transition_in, p as transition_out, f as detach, g as destroy_each, t as text, E as listen, h as set_data, F as run_all, q as src_url_equal, n as noop, u as create_component, v as mount_component, w as destroy_component, y as empty, r as group_outros, o as check_outros, G as globals, j as set_style, k as Stanza, l as defineStanzaElement } from './index-e41a6caa.js';
import { t as toCamelCase } from './CamelCase-d435ec30.js';
import { g as getColor } from './ColorScale-57428e3f.js';
import { F as Fa, a as faTriangleExclamation, f as faCircleChevronRight } from './index-97bbddfa.js';
import { d as drugIcon } from './drug-97ae0c78.js';

// import proteinIcon from "@/assets/protein.svg";
const calculationType = (dataType) => {
  switch (dataType) {
    case "variants":
      return {
        calcName: "variants",
      };
    case "Mutation_FEP":
    case "MP-CAFEE":
      return {
        calcName: "mutation",
        className: "drug-icon",
        src: drugIcon,
        alt: "drug icon",
      };
    default:
      return {
        calcName: "",
        // className: "protein-icon",
        // src: proteinIcon,
        // alt: "protein icon",
      };
  }
};

const scores = [
  "cadd",
  "fathmmMkl",
  "lrt",
  "mutationTaster",
  "mutationAssessor",
  "polyphen2Hdiv",
  "polyphen2Hvar",
  "primateAi",
  "provean",
  "revel",
  "sift4G",
];

const scoreTheads = [
  { className: "th-heatmap", label: "CADD" },
  { className: "th-heatmap", label: "fathmm-MKL" },
  { className: "th-heatmap", label: "LRT" },
  { className: "th-heatmap", label: "MutationTaster" },
  { className: "th-heatmap", label: "MutationAssessor" },
  { className: "th-heatmap", label: "Polyphen2_HDIV" },
  { className: "th-heatmap", label: "Polyphen2_HVAR" },
  { className: "th-heatmap", label: "PrimateAI" },
  { className: "th-heatmap", label: "PROVEAN" },
  { className: "th-heatmap", label: "REVEL" },
  { className: "th-heatmap", label: "SIFT4G" },
];

/* stanzas/heatmap-table/App.svelte generated by Svelte v3.58.0 */

const { Boolean: Boolean_1 } = globals;

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[34] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[38] = list[i].className;
	child_ctx[39] = list[i].label;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	return child_ctx;
}

// (225:4) {#if calculationsLists.length > 0}
function create_if_block_6(ctx) {
	let ul;
	let li;
	let t0;
	let span;
	let t1_value = /*dataset*/ ctx[0].length + "";
	let t1;
	let t2;
	let mounted;
	let dispose;
	let each_value_5 = /*calculationsLists*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	return {
		c() {
			ul = element("ul");
			li = element("li");
			t0 = text("Variants");
			span = element("span");
			t1 = text(t1_value);
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(span, "class", "num");
			attr(li, "class", "selected");
			attr(li, "data-calc", "variants");
			attr(li, "tabindex", "-1");
			attr(ul, "class", "column-ul");
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li);
			append(li, t0);
			append(li, span);
			append(span, t1);
			append(ul, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			if (!mounted) {
				dispose = [
					listen(li, "click", /*calcHandleClick*/ ctx[7]),
					listen(li, "keydown", /*listHandleKeyDown*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*dataset*/ 1 && t1_value !== (t1_value = /*dataset*/ ctx[0].length + "")) set_data(t1, t1_value);

			if (dirty[0] & /*calculationsLists, calcHandleClick, listHandleKeyDown, calculationsCount*/ 390) {
				each_value_5 = /*calculationsLists*/ ctx[1];
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_5.length;
			}
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (236:8) {#each calculationsLists as calc}
function create_each_block_5(ctx) {
	let li;
	let img;
	let img_src_value;
	let img_alt_value;
	let t0_value = /*calc*/ ctx[44] + "";
	let t0;
	let span;
	let t1_value = /*calculationsCount*/ ctx[2][/*calc*/ ctx[44]] + "";
	let t1;
	let t2;
	let li_data_calc_value;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			img = element("img");
			t0 = text(t0_value);
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			attr(img, "class", "icon");
			if (!src_url_equal(img.src, img_src_value = calculationType(/*calc*/ ctx[44]).src)) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = calculationType(/*calc*/ ctx[44]).alt);
			attr(span, "class", "num");
			attr(li, "data-calc", li_data_calc_value = /*calc*/ ctx[44]);
			attr(li, "tabindex", "-1");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, img);
			append(li, t0);
			append(li, span);
			append(span, t1);
			append(li, t2);

			if (!mounted) {
				dispose = [
					listen(li, "click", /*calcHandleClick*/ ctx[7]),
					listen(li, "keydown", /*listHandleKeyDown*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*calculationsLists*/ 2 && !src_url_equal(img.src, img_src_value = calculationType(/*calc*/ ctx[44]).src)) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*calculationsLists*/ 2 && img_alt_value !== (img_alt_value = calculationType(/*calc*/ ctx[44]).alt)) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*calculationsLists*/ 2 && t0_value !== (t0_value = /*calc*/ ctx[44] + "")) set_data(t0, t0_value);
			if (dirty[0] & /*calculationsCount, calculationsLists*/ 6 && t1_value !== (t1_value = /*calculationsCount*/ ctx[2][/*calc*/ ctx[44]] + "")) set_data(t1, t1_value);

			if (dirty[0] & /*calculationsLists*/ 2 && li_data_calc_value !== (li_data_calc_value = /*calc*/ ctx[44])) {
				attr(li, "data-calc", li_data_calc_value);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (253:2) {#if calculationType(selectedCalcName).calcName === "mutation"}
function create_if_block_5(ctx) {
	let div;
	let ul;
	let each_value_4 = /*currentCompoundList*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	return {
		c() {
			div = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "drugs-ul");
			attr(div, "class", "drugs-list");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentCompoundList, compoundHandleClick*/ 520) {
				each_value_4 = /*currentCompoundList*/ ctx[3];
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_4.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (256:8) {#each currentCompoundList as drugName, index}
function create_each_block_4(ctx) {
	let li;
	let t0_value = /*drugName*/ ctx[42] + "";
	let t0;
	let t1;
	let li_data_compound_value;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			attr(li, "class", /*index*/ ctx[30] === 0 ? "selected" : "");
			attr(li, "data-compound", li_data_compound_value = /*drugName*/ ctx[42]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t0);
			append(li, t1);

			if (!mounted) {
				dispose = [
					listen(li, "click", /*compoundHandleClick*/ ctx[9]),
					listen(li, "keydown", /*compoundHandleClick*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentCompoundList*/ 8 && t0_value !== (t0_value = /*drugName*/ ctx[42] + "")) set_data(t0, t0_value);

			if (dirty[0] & /*currentCompoundList*/ 8 && li_data_compound_value !== (li_data_compound_value = /*drugName*/ ctx[42])) {
				attr(li, "data-compound", li_data_compound_value);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (280:12) {#if calculationType(selectedCalcName).calcName !== "variants"}
function create_if_block_4(ctx) {
	let th0;
	let t1;
	let th1;

	return {
		c() {
			th0 = element("th");
			th0.innerHTML = `<p>Single Calculation</p>`;
			t1 = space();
			th1 = element("th");
			th1.innerHTML = `<p>Multiple Calculation</p>`;
			attr(th0, "class", "th-calc th-group");
			attr(th0, "colspan", "1");
			attr(th1, "class", "th-calc th-group");
			attr(th1, "colspan", "2");
		},
		m(target, anchor) {
			insert(target, th0, anchor);
			insert(target, t1, anchor);
			insert(target, th1, anchor);
		},
		d(detaching) {
			if (detaching) detach(th0);
			if (detaching) detach(t1);
			if (detaching) detach(th1);
		}
	};
}

// (289:12) {#each scoreTheads as { className, label }}
function create_each_block_3(ctx) {
	let th;
	let p;
	let t_value = /*label*/ ctx[39] + "";
	let t;

	return {
		c() {
			th = element("th");
			p = element("p");
			t = text(t_value);
			attr(th, "class", /*className*/ ctx[38]);
			attr(th, "rowspan", "2");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, p);
			append(p, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(th);
		}
	};
}

// (296:12) {#if calculationType(selectedCalcName).calcName !== "variants"}
function create_if_block_3(ctx) {
	let th0;
	let t1;
	let th1;
	let t3;
	let th2;

	return {
		c() {
			th0 = element("th");
			th0.innerHTML = `<p>ΔΔG (kcal/mol)</p>`;
			t1 = space();
			th1 = element("th");
			th1.innerHTML = `<p>Average ΔΔG (kcal/mol)</p>`;
			t3 = space();
			th2 = element("th");
			th2.innerHTML = `<p>Standard Deviation</p>`;
			attr(th0, "class", "th-calc");
			attr(th0, "rowspan", "1");
			attr(th0, "data-calc", "mutation");
			attr(th1, "class", "th-calc");
			attr(th1, "rowspan", "1");
			attr(th1, "data-calc", "mutation");
			attr(th2, "class", "th-calc");
			attr(th2, "rowspan", "1");
			attr(th2, "data-calc", "mutation");
		},
		m(target, anchor) {
			insert(target, th0, anchor);
			insert(target, t1, anchor);
			insert(target, th1, anchor);
			insert(target, t3, anchor);
			insert(target, th2, anchor);
		},
		d(detaching) {
			if (detaching) detach(th0);
			if (detaching) detach(t1);
			if (detaching) detach(th1);
			if (detaching) detach(t3);
			if (detaching) detach(th2);
		}
	};
}

// (393:10) {:catch error}
function create_catch_block(ctx) {
	let tr;
	let td;
	let fa;
	let t;
	let br;
	let current;

	fa = new Fa({
			props: {
				icon: faTriangleExclamation,
				size: "90%",
				color: "var(--warning-color)"
			}
		});

	return {
		c() {
			tr = element("tr");
			td = element("td");
			create_component(fa.$$.fragment);
			t = text("\n                Unable to fetch data from the server. Please refresh the page or\n                try again later.");
			br = element("br");
			attr(td, "class", "error-message");
			attr(td, "colspan", "3");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td);
			mount_component(fa, td, null);
			append(td, t);
			append(td, br);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(fa.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fa.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			destroy_component(fa);
		}
	};
}

// (312:10) {:then json}
function create_then_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*currentTabeleList*/ ctx[5];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*tableHandleClick, currentTabeleList, selectedCalcName*/ 1072) {
				each_value = /*currentTabeleList*/ ctx[5];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (349:16) {#if calculationType(selectedCalcName).calcName !== "variants"}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[28].calculation[0]?.FE_Bind?.length === 0) return create_if_block_1;
		if (/*data*/ ctx[28].calculation[0]?.FE_Bind?.length === 1) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (358:18) {:else}
function create_else_block(ctx) {
	let td0;
	let t1;
	let td1;
	let t2_value = /*data*/ ctx[28].calculation[0]?.FE_Bind_mean + "";
	let t2;
	let t3;
	let td2;
	let t4_value = /*data*/ ctx[28].calculation[0]?.FE_Bind_std + "";
	let t4;

	return {
		c() {
			td0 = element("td");
			td0.textContent = " ";
			t1 = space();
			td1 = element("td");
			t2 = text(t2_value);
			t3 = space();
			td2 = element("td");
			t4 = text(t4_value);
		},
		m(target, anchor) {
			insert(target, td0, anchor);
			insert(target, t1, anchor);
			insert(target, td1, anchor);
			append(td1, t2);
			insert(target, t3, anchor);
			insert(target, td2, anchor);
			append(td2, t4);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTabeleList*/ 32 && t2_value !== (t2_value = /*data*/ ctx[28].calculation[0]?.FE_Bind_mean + "")) set_data(t2, t2_value);
			if (dirty[0] & /*currentTabeleList*/ 32 && t4_value !== (t4_value = /*data*/ ctx[28].calculation[0]?.FE_Bind_std + "")) set_data(t4, t4_value);
		},
		d(detaching) {
			if (detaching) detach(td0);
			if (detaching) detach(t1);
			if (detaching) detach(td1);
			if (detaching) detach(t3);
			if (detaching) detach(td2);
		}
	};
}

// (354:71) 
function create_if_block_2(ctx) {
	let td0;
	let t0_value = /*data*/ ctx[28].calculation[0]?.FE_Bind + "";
	let t0;
	let t1;
	let td1;
	let t3;
	let td2;

	return {
		c() {
			td0 = element("td");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			td1.textContent = " ";
			t3 = space();
			td2 = element("td");
			td2.textContent = " ";
		},
		m(target, anchor) {
			insert(target, td0, anchor);
			append(td0, t0);
			insert(target, t1, anchor);
			insert(target, td1, anchor);
			insert(target, t3, anchor);
			insert(target, td2, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTabeleList*/ 32 && t0_value !== (t0_value = /*data*/ ctx[28].calculation[0]?.FE_Bind + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(td0);
			if (detaching) detach(t1);
			if (detaching) detach(td1);
			if (detaching) detach(t3);
			if (detaching) detach(td2);
		}
	};
}

// (350:18) {#if data.calculation[0]?.FE_Bind?.length === 0}
function create_if_block_1(ctx) {
	let td0;
	let t1;
	let td1;
	let t3;
	let td2;

	return {
		c() {
			td0 = element("td");
			td0.textContent = " ";
			t1 = space();
			td1 = element("td");
			td1.textContent = " ";
			t3 = space();
			td2 = element("td");
			td2.textContent = " ";
		},
		m(target, anchor) {
			insert(target, td0, anchor);
			insert(target, t1, anchor);
			insert(target, td1, anchor);
			insert(target, t3, anchor);
			insert(target, td2, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(td0);
			if (detaching) detach(t1);
			if (detaching) detach(td1);
			if (detaching) detach(t3);
			if (detaching) detach(td2);
		}
	};
}

// (365:18) {#each data.calculation as calculation}
function create_each_block_2(ctx) {
	let a;
	let img;
	let img_src_value;
	let img_alt_value;
	let span;
	let t0_value = /*calculation*/ ctx[34].calculation_type + "";
	let t0;
	let a_href_value;
	let t1;
	let br;

	return {
		c() {
			a = element("a");
			img = element("img");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			br = element("br");
			attr(img, "class", "icon");

			if (!src_url_equal(img.src, img_src_value = calculationType(/*calculation*/ ctx[34].calculation_type).src
			? calculationType(/*calculation*/ ctx[34].calculation_type).src
			: "")) attr(img, "src", img_src_value);

			attr(img, "alt", img_alt_value = calculationType(/*calculation*/ ctx[34].calculation_type).alt
			? calculationType(/*calculation*/ ctx[34].calculation_type).alt
			: "");

			attr(a, "class", "link-calc");
			attr(a, "href", a_href_value = `${window.location.origin}/dev/calculation/details?assembly=${/*data*/ ctx[28].assembly}&genename=${/*data*/ ctx[28].genename}&calculation_type=${/*calculation*/ ctx[34].calculation_type}&Compound_ID=${/*data*/ ctx[28].compoundId}&PDB_ID=${/*calculation*/ ctx[34].PDB_ID}&variant=${/*data*/ ctx[28].variant}`);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, img);
			append(a, span);
			append(span, t0);
			insert(target, t1, anchor);
			insert(target, br, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTabeleList*/ 32 && !src_url_equal(img.src, img_src_value = calculationType(/*calculation*/ ctx[34].calculation_type).src
			? calculationType(/*calculation*/ ctx[34].calculation_type).src
			: "")) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*currentTabeleList*/ 32 && img_alt_value !== (img_alt_value = calculationType(/*calculation*/ ctx[34].calculation_type).alt
			? calculationType(/*calculation*/ ctx[34].calculation_type).alt
			: "")) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*currentTabeleList*/ 32 && t0_value !== (t0_value = /*calculation*/ ctx[34].calculation_type + "")) set_data(t0, t0_value);

			if (dirty[0] & /*currentTabeleList*/ 32 && a_href_value !== (a_href_value = `${window.location.origin}/dev/calculation/details?assembly=${/*data*/ ctx[28].assembly}&genename=${/*data*/ ctx[28].genename}&calculation_type=${/*calculation*/ ctx[34].calculation_type}&Compound_ID=${/*data*/ ctx[28].compoundId}&PDB_ID=${/*calculation*/ ctx[34].PDB_ID}&variant=${/*data*/ ctx[28].variant}`)) {
				attr(a, "href", a_href_value);
			}
		},
		d(detaching) {
			if (detaching) detach(a);
			if (detaching) detach(t1);
			if (detaching) detach(br);
		}
	};
}

// (383:16) {#each scores as key}
function create_each_block_1(ctx) {
	let td;
	let div;

	return {
		c() {
			td = element("td");
			div = element("div");
			attr(div, "class", "cell");
			set_style(div, "background-color", getColor(/*data*/ ctx[28][/*key*/ ctx[31]]));
			attr(td, "class", "cell-td");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, div);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*currentTabeleList*/ 32) {
				set_style(div, "background-color", getColor(/*data*/ ctx[28][/*key*/ ctx[31]]));
			}
		},
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

// (313:12) {#each currentTabeleList as data, index}
function create_each_block(ctx) {
	let tr;
	let td0;
	let input;
	let input_value_value;
	let t0;
	let t1_value = /*data*/ ctx[28].uniprotAcc + "";
	let t1;
	let t2;
	let td1;
	let a;
	let t3_value = /*data*/ ctx[28].variant + "";
	let t3;
	let fa;
	let a_href_value;
	let t4;
	let td2;

	let t5_value = (/*data*/ ctx[28].genBank[0] === undefined
	? "-"
	: /*data*/ ctx[28].genBank) + "";

	let t5;
	let t6;
	let td3;

	let t7_value = (/*data*/ ctx[28].mGeNdClinicalSignificance[0] === undefined
	? ""
	: /*data*/ ctx[28].mGeNdClinicalSignificance) + "";

	let t7;
	let t8;
	let td4;

	let t9_value = (/*data*/ ctx[28].clinVarClinicalSignificance[0] === undefined
	? ""
	: /*data*/ ctx[28].clinVarClinicalSignificance) + "";

	let t9;
	let t10;
	let show_if = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";
	let t11;
	let td5;
	let t12;
	let t13;
	let current;
	let mounted;
	let dispose;

	fa = new Fa({
			props: {
				icon: faCircleChevronRight,
				size: "90%",
				color: "var(--variant-color)"
			}
		});

	let if_block = show_if && create_if_block(ctx);
	let each_value_2 = /*data*/ ctx[28].calculation;
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = scores;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function click_handler(...args) {
		return /*click_handler*/ ctx[15](/*data*/ ctx[28], ...args);
	}

	return {
		c() {
			tr = element("tr");
			td0 = element("td");
			input = element("input");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			td1 = element("td");
			a = element("a");
			t3 = text(t3_value);
			create_component(fa.$$.fragment);
			t4 = space();
			td2 = element("td");
			t5 = text(t5_value);
			t6 = space();
			td3 = element("td");
			t7 = text(t7_value);
			t8 = space();
			td4 = element("td");
			t9 = text(t9_value);
			t10 = space();
			if (if_block) if_block.c();
			t11 = space();
			td5 = element("td");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t12 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t13 = space();
			attr(input, "class", "radio-button");
			attr(input, "type", "radio");
			attr(input, "name", "variantid");
			input.value = input_value_value = /*data*/ ctx[28].uniprotAcc;
			attr(td0, "class", "td-uniprot");
			attr(a, "class", "link-variant");
			attr(a, "href", a_href_value = `${window.location.origin}/dev/variants/details?assembly=${/*data*/ ctx[28].assembly}&chr=${/*data*/ ctx[28].chr}&start=${/*data*/ ctx[28].start}&end=${/*data*/ ctx[28].end}&ref=${/*data*/ ctx[28].ref}&alt=${/*data*/ ctx[28].alt}&variant=${/*data*/ ctx[28].variant}`);
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td0);
			append(td0, input);
			append(td0, t0);
			append(td0, t1);
			append(tr, t2);
			append(tr, td1);
			append(td1, a);
			append(a, t3);
			mount_component(fa, a, null);
			append(tr, t4);
			append(tr, td2);
			append(td2, t5);
			append(tr, t6);
			append(tr, td3);
			append(td3, t7);
			append(tr, t8);
			append(tr, td4);
			append(td4, t9);
			append(tr, t10);
			if (if_block) if_block.m(tr, null);
			append(tr, t11);
			append(tr, td5);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(td5, null);
				}
			}

			append(tr, t12);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr, null);
				}
			}

			append(tr, t13);
			current = true;

			if (!mounted) {
				dispose = listen(tr, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*currentTabeleList*/ 32 && input_value_value !== (input_value_value = /*data*/ ctx[28].uniprotAcc)) {
				input.value = input_value_value;
			}

			if ((!current || dirty[0] & /*currentTabeleList*/ 32) && t1_value !== (t1_value = /*data*/ ctx[28].uniprotAcc + "")) set_data(t1, t1_value);
			if ((!current || dirty[0] & /*currentTabeleList*/ 32) && t3_value !== (t3_value = /*data*/ ctx[28].variant + "")) set_data(t3, t3_value);

			if (!current || dirty[0] & /*currentTabeleList*/ 32 && a_href_value !== (a_href_value = `${window.location.origin}/dev/variants/details?assembly=${/*data*/ ctx[28].assembly}&chr=${/*data*/ ctx[28].chr}&start=${/*data*/ ctx[28].start}&end=${/*data*/ ctx[28].end}&ref=${/*data*/ ctx[28].ref}&alt=${/*data*/ ctx[28].alt}&variant=${/*data*/ ctx[28].variant}`)) {
				attr(a, "href", a_href_value);
			}

			if ((!current || dirty[0] & /*currentTabeleList*/ 32) && t5_value !== (t5_value = (/*data*/ ctx[28].genBank[0] === undefined
			? "-"
			: /*data*/ ctx[28].genBank) + "")) set_data(t5, t5_value);

			if ((!current || dirty[0] & /*currentTabeleList*/ 32) && t7_value !== (t7_value = (/*data*/ ctx[28].mGeNdClinicalSignificance[0] === undefined
			? ""
			: /*data*/ ctx[28].mGeNdClinicalSignificance) + "")) set_data(t7, t7_value);

			if ((!current || dirty[0] & /*currentTabeleList*/ 32) && t9_value !== (t9_value = (/*data*/ ctx[28].clinVarClinicalSignificance[0] === undefined
			? ""
			: /*data*/ ctx[28].clinVarClinicalSignificance) + "")) set_data(t9, t9_value);

			if (dirty[0] & /*selectedCalcName*/ 16) show_if = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(tr, t11);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*currentTabeleList*/ 32) {
				each_value_2 = /*data*/ ctx[28].calculation;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(td5, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_2.length;
			}

			if (dirty[0] & /*currentTabeleList*/ 32) {
				each_value_1 = scores;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t13);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(fa.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(fa.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			destroy_component(fa);
			if (if_block) if_block.d();
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (310:26)              <tr><td colspan="3" class="loading-message">Loading...</td></tr>           {:then json}
function create_pending_block(ctx) {
	let tr;

	return {
		c() {
			tr = element("tr");
			tr.innerHTML = `<td colspan="3" class="loading-message">Loading...</td>`;
		},
		m(target, anchor) {
			insert(target, tr, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(tr);
		}
	};
}

function create_fragment(ctx) {
	let div5;
	let div0;
	let t0;
	let show_if_2 = calculationType(/*selectedCalcName*/ ctx[4]).calcName === "mutation";
	let t1;
	let div4;
	let div1;
	let table;
	let thead;
	let tr0;
	let th0;
	let t3;
	let th1;
	let t5;
	let th2;
	let t7;
	let th3;
	let t9;
	let show_if_1 = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";
	let t10;
	let th4;
	let t12;
	let t13;
	let tr1;
	let th5;
	let t15;
	let th6;
	let t17;
	let show_if = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";
	let t18;
	let tbody;
	let t19;
	let div3;
	let current;
	let if_block0 = /*calculationsLists*/ ctx[1].length > 0 && create_if_block_6(ctx);
	let if_block1 = show_if_2 && create_if_block_5(ctx);
	let if_block2 = show_if_1 && create_if_block_4();
	let each_value_3 = scoreTheads;
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let if_block3 = show_if && create_if_block_3();

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 27,
		error: 37,
		blocks: [,,,]
	};

	handle_promise(/*promise*/ ctx[6], info);

	return {
		c() {
			div5 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			div4 = element("div");
			div1 = element("div");
			table = element("table");
			thead = element("thead");
			tr0 = element("tr");
			th0 = element("th");
			th0.textContent = "UniProt acc";
			t3 = space();
			th1 = element("th");
			th1.textContent = "Variant";
			t5 = space();
			th2 = element("th");
			th2.textContent = "GenBank";
			t7 = space();
			th3 = element("th");
			th3.textContent = "Significance";
			t9 = space();
			if (if_block2) if_block2.c();
			t10 = space();
			th4 = element("th");
			th4.textContent = "Calculation";
			t12 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t13 = space();
			tr1 = element("tr");
			th5 = element("th");
			th5.textContent = "MGeND";
			t15 = space();
			th6 = element("th");
			th6.textContent = "ClinVar";
			t17 = space();
			if (if_block3) if_block3.c();
			t18 = space();
			tbody = element("tbody");
			info.block.c();
			t19 = space();
			div3 = element("div");

			div3.innerHTML = `<p>Benign</p> 
      <div class="legend-bar"></div> 
      <p>Pathogenic</p>`;

			attr(div0, "class", "column-list");
			attr(th0, "class", "th-gene");
			attr(th0, "rowspan", "2");
			attr(th1, "class", "th-variant");
			attr(th1, "rowspan", "2");
			attr(th2, "class", "th-variant");
			attr(th2, "rowspan", "2");
			attr(th3, "class", "th-disease th-group");
			attr(th3, "colspan", "2");
			attr(th4, "class", "th-calc");
			attr(th4, "rowspan", "2");
			attr(th5, "class", "th-disease");
			attr(th5, "rowspan", "1");
			attr(th6, "class", "th-disease");
			attr(th6, "rowspan", "1");
			attr(div1, "class", "table-wrapper");
			attr(div3, "class", "legend");
			attr(div4, "class", "table-container");
			attr(div5, "class", "heatmap-table");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div5, t0);
			if (if_block1) if_block1.m(div5, null);
			append(div5, t1);
			append(div5, div4);
			append(div4, div1);
			append(div1, table);
			append(table, thead);
			append(thead, tr0);
			append(tr0, th0);
			append(tr0, t3);
			append(tr0, th1);
			append(tr0, t5);
			append(tr0, th2);
			append(tr0, t7);
			append(tr0, th3);
			append(tr0, t9);
			if (if_block2) if_block2.m(tr0, null);
			append(tr0, t10);
			append(tr0, th4);
			append(tr0, t12);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr0, null);
				}
			}

			append(thead, t13);
			append(thead, tr1);
			append(tr1, th5);
			append(tr1, t15);
			append(tr1, th6);
			append(tr1, t17);
			if (if_block3) if_block3.m(tr1, null);
			append(table, t18);
			append(table, tbody);
			info.block.m(tbody, info.anchor = null);
			info.mount = () => tbody;
			info.anchor = null;
			append(div4, t19);
			append(div4, div3);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*calculationsLists*/ ctx[1].length > 0) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*selectedCalcName*/ 16) show_if_2 = calculationType(/*selectedCalcName*/ ctx[4]).calcName === "mutation";

			if (show_if_2) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5(ctx);
					if_block1.c();
					if_block1.m(div5, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*selectedCalcName*/ 16) show_if_1 = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";

			if (show_if_1) {
				if (if_block2) ; else {
					if_block2 = create_if_block_4();
					if_block2.c();
					if_block2.m(tr0, t10);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*scoreTheads*/ 0) {
				each_value_3 = scoreTheads;
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty[0] & /*selectedCalcName*/ 16) show_if = calculationType(/*selectedCalcName*/ ctx[4]).calcName !== "variants";

			if (show_if) {
				if (if_block3) ; else {
					if_block3 = create_if_block_3();
					if_block3.c();
					if_block3.m(tr1, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			update_await_block_branch(info, ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			destroy_each(each_blocks, detaching);
			if (if_block3) if_block3.d();
			info.block.d();
			info.token = null;
			info = null;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { uniprotAcc, assembly, genename, root } = $$props;
	let promise = fetchData();
	let dataset = [];
	let calculationsLists = [];
	let calculationsCount = {};
	let datasetMap = [];
	let compoundMap = new Map();
	let currentCompoundList = [];
	let selectedCalcName = "variants";
	let currentTabeleList = [];
	let tableSelectedItem = {};

	const getCalculationsLists = dataset => {
		const calculations = dataset.flatMap(data => data.calculation.map(d => d.calculation_type));
		const uniqueCalculations = [...new Set(calculations.filter(Boolean))];

		const calculationsCount = calculations.reduce(
			(acc, calcType) => {
				acc[calcType] = (acc[calcType] || 0) + 1;
				return acc;
			},
			{}
		);

		return [uniqueCalculations, calculationsCount];
	};

	const getMapLists = () => {
		datasetMap = new Map([["variants", dataset]]);

		calculationsLists.forEach(calc => {
			const filteredData = dataset.filter(data => data.calculation.some(type => type.calculation_type === calc)).map(data => ({
				...data,
				calculation: data.calculation.filter(item => item.calculation_type === calc)
			}));

			datasetMap.set(calc, filteredData);

			const compoundGroup = filteredData.reduce(
				(acc, data) => {
					const compound = data.compoundId;

					if (!acc[compound]) {
						acc[compound] = [];
					}

					acc[compound].push(data);
					return acc;
				},
				{}
			);

			const compoundList = [
				{
					"All Drugs": filteredData,
					...compoundGroup
				}
			];

			compoundMap.set(calc, ...compoundList);
		});

		return [datasetMap, compoundMap];
	};

	async function fetchData() {
		const response = await fetch(//`https://precisionmd-db.med.kyoto-u.ac.jp/testapi/genes/variants?uniprot_acc=${uniprotAcc}&assembly=${assembly}&genename=${genename}&limit=10000`
		"https://raw.githubusercontent.com/PENQEinc/riken-precision_medicine_stanza/feature/fetch-heatmap/stanzas/heatmap-table/assets/geneVariantSample.json?token=$(date +%s)"); //`https://precisionmd-db.med.kyoto-u.ac.jp/api/genes/variants?uniprot_acc=${uniprotAcc}&assembly=${assembly}&genename=${genename}`

		const json = await response.json();

		if (response.ok) {
			$$invalidate(0, dataset = json.data.map(toCamelCase));
			$$invalidate(5, currentTabeleList = dataset);
			$$invalidate(1, [calculationsLists, calculationsCount] = getCalculationsLists(dataset), calculationsLists, $$invalidate(2, calculationsCount));
			[datasetMap, compoundMap] = getMapLists();
		} else {
			throw new Error(json);
		}
	}

	const initTableSelected = () => {
		if (root.querySelector("tbody")) {
			const trs = root.querySelectorAll("tbody > tr");

			trs.forEach(tr => {
				const radio = tr.querySelector('input[type="radio"]');

				if (radio.checked) {
					radio.checked = false;
				}
			});

			if (root.querySelector("tbody > tr.selected")) {
				root.querySelector("tbody > tr.selected").classList.remove("selected");
			}
		}
	};

	let selectedCalcEl = null;

	const calcHandleClick = event => {
		const clickedItem = event.target.closest("li");
		$$invalidate(4, selectedCalcName = clickedItem.dataset.calc);
		$$invalidate(5, currentTabeleList = datasetMap.get(selectedCalcName));

		$$invalidate(3, currentCompoundList = selectedCalcName === "variants"
		? ""
		: Object.keys(compoundMap.get(selectedCalcName)));

		if (clickedItem !== selectedCalcEl) {
			clickedItem.parentElement.querySelectorAll("li").forEach(li => {
				if (li.classList.contains("selected")) {
					li.classList.remove("selected");
				}
			});

			selectedCalcEl = clickedItem;
			selectedCalcEl.classList.add("selected");
			initTableSelected();
		}
	};

	const listHandleKeyDown = event => {
		event.preventDefault();
		const ul = event.target.closest("li").parentElement;
		const listItems = ul.querySelectorAll("li");
		let selectedIndex = null;

		listItems.forEach((li, index) => {
			if (li.classList.contains("selected")) {
				selectedIndex = index;
			}
		});

		switch (event.key) {
			case "ArrowUp":
				if (selectedIndex > 0) {
					listItems[selectedIndex].classList.remove("selected");
					listItems[selectedIndex - 1].classList.add("selected");
					selectedCalcEl = listItems[selectedIndex - 1];
				} else {
					listItems[0].classList.remove("selected");
					listItems[listItems.length - 1].classList.add("selected");
					selectedCalcEl = listItems[listItems.length - 1];
				}
				break;
			case "ArrowDown":
				if (selectedIndex < listItems.length - 1) {
					listItems[selectedIndex].classList.remove("selected");
					listItems[selectedIndex + 1].classList.add("selected");
					selectedCalcEl = listItems[selectedIndex + 1];
				} else {
					listItems[listItems.length - 1].classList.remove("selected");
					listItems[0].classList.add("selected");
					selectedCalcEl = listItems[0];
				}
				break;
		}

		$$invalidate(4, selectedCalcName = selectedCalcEl.dataset.calc);
		$$invalidate(5, currentTabeleList = datasetMap.get(selectedCalcName));

		$$invalidate(3, currentCompoundList = selectedCalcName === "variants"
		? ""
		: Object.keys(compoundMap.get(selectedCalcName)));
	};

	let selectedCompoundEl = null;
	let selectedCompoundName = "All Drugs";

	const compoundHandleClick = event => {
		const clickedItem = event.target.closest("li");
		selectedCompoundName = clickedItem.textContent.trim();

		if (clickedItem !== selectedCompoundEl) {
			clickedItem.parentElement.querySelectorAll("li").forEach(li => {
				if (li.classList.contains("selected")) {
					li.classList.remove("selected");
				}
			});

			selectedCompoundEl = clickedItem;
			selectedCompoundEl.classList.add("selected");
			$$invalidate(5, currentTabeleList = compoundMap.get(selectedCalcName)[selectedCompoundName]);
		}

		initTableSelected();
	};

	let tableSelectedEl = null;

	const tableHandleClick = (event, data) => {
		const variantLink = event.target.closest(".td-variant > span");
		const calculationList = event.target.closest(".td-calc > span");
		if (variantLink || calculationList) return;
		const clickedItem = event.target.closest("tr");
		const radioButton = clickedItem.querySelector('input[type="radio"]');
		clickedItem.parentElement.firstChild.classList.remove("selected");

		if (clickedItem !== tableSelectedEl) {
			if (tableSelectedEl) {
				tableSelectedEl.classList.remove("selected");
				tableSelectedEl.querySelector('input[type="radio"]').checked = false;
			}

			tableSelectedEl = clickedItem;
			tableSelectedEl.classList.add("selected");
			radioButton.checked = true;
			tableSelectedItem = data;

			window.dispatchEvent(new CustomEvent("updateGraphs",
			{
					// TODO: change to data.variant to data.pdbId (or others)
					detail: { clicked: tableSelectedItem }
				}));
		} else {
			tableSelectedEl = null;
			tableSelectedItem = {};
			clickedItem.classList.remove("selected");
			radioButton.checked = false;
		}
	};

	const click_handler = (data, event) => tableHandleClick(event, data);

	$$self.$$set = $$props => {
		if ('uniprotAcc' in $$props) $$invalidate(11, uniprotAcc = $$props.uniprotAcc);
		if ('assembly' in $$props) $$invalidate(12, assembly = $$props.assembly);
		if ('genename' in $$props) $$invalidate(13, genename = $$props.genename);
		if ('root' in $$props) $$invalidate(14, root = $$props.root);
	};

	return [
		dataset,
		calculationsLists,
		calculationsCount,
		currentCompoundList,
		selectedCalcName,
		currentTabeleList,
		promise,
		calcHandleClick,
		listHandleKeyDown,
		compoundHandleClick,
		tableHandleClick,
		uniprotAcc,
		assembly,
		genename,
		root,
		click_handler
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				uniprotAcc: 11,
				assembly: 12,
				genename: 13,
				root: 14
			},
			null,
			[-1, -1]
		);
	}
}

class HeatmapTable extends Stanza {
  app = null;

  async render() {
    if (this.app) {
      this.root.querySelector("main > .heatmap-table").remove();
    }
    this.app = new App({
      target: this.root.querySelector("main"),
      props: {
        uniprotAcc: toCamelCase(this.params)["stanzaUniprotAcc"],
        assembly: toCamelCase(this.params)["stanzaAssembly"],
        genename: toCamelCase(this.params)["stanzaGenename"],
        root: this.root.querySelector("main"),
      },
    });
  }
}

var stanzaModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': HeatmapTable
});

var metadata = {
	"@context": {
	stanza: "http://togostanza.org/resource/stanza#"
},
	"@id": "heatmap-table",
	"stanza:label": "Heatmap table",
	"stanza:definition": "For PrecisionMD-DB",
	"stanza:license": "MIT",
	"stanza:author": "PENQE",
	"stanza:contributor": [
	"Yukiko Noda"
],
	"stanza:created": "2023-03-16",
	"stanza:updated": "2023-03-16",
	"stanza:parameter": [
	{
		"stanza:key": "stanza-uniprot_acc",
		"stanza:example": "Q9UM73",
		"stanza:description": "Uniprot_acc",
		"stanza:required": true
	},
	{
		"stanza:key": "stanza-assembly",
		"stanza:example": "hg38",
		"stanza:description": "Assembly",
		"stanza:required": true
	},
	{
		"stanza:key": "stanza-genename",
		"stanza:example": "ALK",
		"stanza:description": "Genename",
		"stanza:required": true
	}
],
	"stanza:menu-placement": "none",
	"stanza:style": [
	{
		"stanza:key": "--togostanza-canvas-height",
		"stanza:type": "number",
		"stanza:default": 350,
		"stanza:description": "Canvas height"
	},
	{
		"stanza:key": "--togostanza-theme-background_color",
		"stanza:type": "color",
		"stanza:default": "#11435c",
		"stanza:description": "Background color"
	},
	{
		"stanza:key": "--togostanza-fonts-font_family",
		"stanza:type": "text",
		"stanza:default": "Helvetica Neue, Arial, sans-serif",
		"stanza:description": "Font family"
	},
	{
		"stanza:key": "--togostanza-fonts-font_color",
		"stanza:type": "color",
		"stanza:default": "#ffffff",
		"stanza:description": "Text color"
	},
	{
		"stanza:key": "--togostanza-fonts-font_size_primary",
		"stanza:type": "number",
		"stanza:default": 14,
		"stanza:description": "Primary font size"
	},
	{
		"stanza:key": "--togostanza-fonts-font_align",
		"stanza:type": "single-choice",
		"stanza:choice": [
			"left",
			"center",
			"right"
		],
		"stanza:default": "center",
		"stanza:description": "text align of greeting"
	}
],
	"stanza:incomingEvent": [
],
	"stanza:outgoingEvent": [
]
};

var templates = [
  
];

const url = import.meta.url.replace(/\?.*$/, '');

defineStanzaElement({stanzaModule, metadata, templates, url});
//# sourceMappingURL=heatmap-table.js.map
