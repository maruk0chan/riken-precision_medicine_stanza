import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, a as space, b as attr, c as insert, d as append, n as noop, f as detach, g as destroy_each, t as text, h as set_data, j as set_style, k as Stanza, l as defineStanzaElement } from './index-e41a6caa.js';
import { g as getColor } from './ColorScale-57428e3f.js';

const annotationTh = [
  "Significance",
  "Disease name",
  "Number of Variants",
];

const oncoKbTh = ["Oncogenic", "Mutation Effect"];

const oncoKbLevelList = [
  { key: "Asimertinib", value: "3A" },
  { key: "Afatinib", value: "1B" },
];

const predictionScoreTh = [
  "CADD",
  "fathmm-MKL",
  "LRT",
  "MutationTaster",
  "MutationAssessor",
  "Polyphen2_HDIV",
  "Polyphen2_HVAR",
  "PrimateAI",
  "PROVEAN",
  "REVEL",
  "SIFT",
  "SIFT4G",
  "EVE",
];
const predictionScore = [
  0, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.55, 0.6, 0.7, 0.8, 0.9, 1,
];

/* stanzas/annotation-keyvalue/App.svelte generated by Svelte v3.58.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i].key;
	child_ctx[8] = list[i].value;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].mutation_effect;
	child_ctx[12] = list[i].oncogenic;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i].index;
	child_ctx[18] = list[i].significance;
	child_ctx[19] = list[i].diseases;
	child_ctx[20] = list[i].number_of_variants;
	return child_ctx;
}

function get_each_context_6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (100:2) {#if !!annotation}
function create_if_block(ctx) {
	return { c: noop, m: noop, d: noop };
}

// (106:8) {#each annotationTh as th, index}
function create_each_block_6(ctx) {
	let th;
	let t_value = /*th*/ ctx[4] + "";
	let t;

	return {
		c() {
			th = element("th");
			t = text(t_value);
			attr(th, "colspan", /*index*/ ctx[17] === 0 ? "2" : "0");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(th);
		}
	};
}

// (112:6) {#each annotation.default as { index, significance, diseases, number_of_variants }}
function create_each_block_5(ctx) {
	let tr;
	let th;
	let t0_value = /*index*/ ctx[17] + "";
	let t0;
	let t1;
	let td0;
	let t2_value = /*significance*/ ctx[18] + "";
	let t2;
	let t3;
	let td1;
	let t4_value = /*diseases*/ ctx[19] + "";
	let t4;
	let t5;
	let td2;
	let t6_value = /*number_of_variants*/ ctx[20] + "";
	let t6;
	let t7;

	return {
		c() {
			tr = element("tr");
			th = element("th");
			t0 = text(t0_value);
			t1 = space();
			td0 = element("td");
			t2 = text(t2_value);
			t3 = space();
			td1 = element("td");
			t4 = text(t4_value);
			t5 = space();
			td2 = element("td");
			t6 = text(t6_value);
			t7 = space();
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, th);
			append(th, t0);
			append(tr, t1);
			append(tr, td0);
			append(td0, t2);
			append(tr, t3);
			append(tr, td1);
			append(td1, t4);
			append(tr, t5);
			append(tr, td2);
			append(td2, t6);
			append(tr, t7);
		},
		p(ctx, dirty) {
			if (dirty & /*annotation*/ 1 && t0_value !== (t0_value = /*index*/ ctx[17] + "")) set_data(t0, t0_value);
			if (dirty & /*annotation*/ 1 && t2_value !== (t2_value = /*significance*/ ctx[18] + "")) set_data(t2, t2_value);
			if (dirty & /*annotation*/ 1 && t4_value !== (t4_value = /*diseases*/ ctx[19] + "")) set_data(t4, t4_value);
			if (dirty & /*annotation*/ 1 && t6_value !== (t6_value = /*number_of_variants*/ ctx[20] + "")) set_data(t6, t6_value);
		},
		d(detaching) {
			if (detaching) detach(tr);
		}
	};
}

// (127:8) {#each oncoKbTh as th}
function create_each_block_4(ctx) {
	let th;
	let t_value = /*th*/ ctx[4] + "";
	let t;

	return {
		c() {
			th = element("th");
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(th);
		}
	};
}

// (133:6) {#each annotation.oncokb as { mutation_effect, oncogenic }}
function create_each_block_3(ctx) {
	let tr;
	let td0;
	let t0_value = /*oncogenic*/ ctx[12] + "";
	let t0;
	let t1;
	let td1;
	let t2_value = /*mutation_effect*/ ctx[11] + "";
	let t2;
	let t3;

	return {
		c() {
			tr = element("tr");
			td0 = element("td");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			t2 = text(t2_value);
			t3 = space();
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td0);
			append(td0, t0);
			append(tr, t1);
			append(tr, td1);
			append(td1, t2);
			append(tr, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*annotation*/ 1 && t0_value !== (t0_value = /*oncogenic*/ ctx[12] + "")) set_data(t0, t0_value);
			if (dirty & /*annotation*/ 1 && t2_value !== (t2_value = /*mutation_effect*/ ctx[11] + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(tr);
		}
	};
}

// (145:6) {#each oncoKbLevelList as { key, value }}
function create_each_block_2(ctx) {
	let tr;
	let th;
	let t0_value = /*key*/ ctx[7] + "";
	let t0;
	let t1;
	let td;
	let t2_value = /*value*/ ctx[8] + "";
	let t2;
	let t3;

	return {
		c() {
			tr = element("tr");
			th = element("th");
			t0 = text(t0_value);
			t1 = space();
			td = element("td");
			t2 = text(t2_value);
			t3 = space();
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, th);
			append(th, t0);
			append(tr, t1);
			append(tr, td);
			append(td, t2);
			append(tr, t3);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(tr);
		}
	};
}

// (158:8) {#each predictionScoreTh as th}
function create_each_block_1(ctx) {
	let th;
	let p;
	let t_value = /*th*/ ctx[4] + "";
	let t;

	return {
		c() {
			th = element("th");
			p = element("p");
			t = text(t_value);
			attr(th, "class", "th-heatmap");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, p);
			append(p, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(th);
		}
	};
}

// (165:8) {#each predictionScore as score}
function create_each_block(ctx) {
	let td;
	let div;
	let t;

	return {
		c() {
			td = element("td");
			div = element("div");
			t = space();
			attr(div, "class", "cell");
			set_style(div, "background-color", getColor(/*score*/ ctx[1]));
			attr(td, "class", "cell-td");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, div);
			append(td, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let h3;
	let t1;
	let t2;
	let table0;
	let thead0;
	let tr0;
	let t3;
	let tbody0;
	let t4;
	let h40;
	let t6;
	let table1;
	let thead1;
	let tr1;
	let t7;
	let tbody1;
	let t8;
	let h41;
	let t10;
	let table2;
	let tbody2;
	let t11;
	let h42;
	let t13;
	let table3;
	let thead2;
	let tr2;
	let t14;
	let tbody3;
	let tr3;
	let t15;
	let div1;
	let if_block = !!/*annotation*/ ctx[0] && create_if_block();
	let each_value_6 = annotationTh;
	let each_blocks_6 = [];

	for (let i = 0; i < each_value_6.length; i += 1) {
		each_blocks_6[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
	}

	let each_value_5 = /*annotation*/ ctx[0].default;
	let each_blocks_5 = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks_5[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	let each_value_4 = oncoKbTh;
	let each_blocks_4 = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks_4[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	let each_value_3 = /*annotation*/ ctx[0].oncokb;
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let each_value_2 = oncoKbLevelList;
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let each_value_1 = predictionScoreTh;
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = predictionScore;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			h3 = element("h3");
			h3.textContent = "Annotation";
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			table0 = element("table");
			thead0 = element("thead");
			tr0 = element("tr");

			for (let i = 0; i < each_blocks_6.length; i += 1) {
				each_blocks_6[i].c();
			}

			t3 = space();
			tbody0 = element("tbody");

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].c();
			}

			t4 = space();
			h40 = element("h4");
			h40.textContent = "OncoKB";
			t6 = space();
			table1 = element("table");
			thead1 = element("thead");
			tr1 = element("tr");

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			t7 = space();
			tbody1 = element("tbody");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t8 = space();
			h41 = element("h4");
			h41.textContent = "Annotation";
			t10 = space();
			table2 = element("table");
			tbody2 = element("tbody");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t11 = space();
			h42 = element("h4");
			h42.textContent = "Prediction Score";
			t13 = space();
			table3 = element("table");
			thead2 = element("thead");
			tr2 = element("tr");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t14 = space();
			tbody3 = element("tbody");
			tr3 = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t15 = space();
			div1 = element("div");

			div1.innerHTML = `<p>benign</p> 
    <div class="legend-bar"></div> 
    <p>pathogenic</p>`;

			attr(h3, "class", "h3 title");
			attr(table0, "class", "table");
			attr(h40, "class", "h4 title");
			attr(table1, "class", "table");
			attr(h41, "class", "h4 title");
			attr(table2, "class", "table");
			attr(h42, "class", "h4 title");
			attr(table3, "class", "heatmap");
			attr(div1, "class", "legend");
			attr(div2, "class", "annotation-keyvalue");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, h3);
			append(div2, t1);
			if (if_block) if_block.m(div2, null);
			append(div2, t2);
			append(div2, table0);
			append(table0, thead0);
			append(thead0, tr0);

			for (let i = 0; i < each_blocks_6.length; i += 1) {
				if (each_blocks_6[i]) {
					each_blocks_6[i].m(tr0, null);
				}
			}

			append(table0, t3);
			append(table0, tbody0);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				if (each_blocks_5[i]) {
					each_blocks_5[i].m(tbody0, null);
				}
			}

			append(div2, t4);
			append(div2, h40);
			append(div2, t6);
			append(div2, table1);
			append(table1, thead1);
			append(thead1, tr1);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				if (each_blocks_4[i]) {
					each_blocks_4[i].m(tr1, null);
				}
			}

			append(table1, t7);
			append(table1, tbody1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				if (each_blocks_3[i]) {
					each_blocks_3[i].m(tbody1, null);
				}
			}

			append(div2, t8);
			append(div2, h41);
			append(div2, t10);
			append(div2, table2);
			append(table2, tbody2);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				if (each_blocks_2[i]) {
					each_blocks_2[i].m(tbody2, null);
				}
			}

			append(div2, t11);
			append(div2, h42);
			append(div2, t13);
			append(div2, table3);
			append(table3, thead2);
			append(thead2, tr2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(tr2, null);
				}
			}

			append(table3, t14);
			append(table3, tbody3);
			append(tbody3, tr3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr3, null);
				}
			}

			append(div2, t15);
			append(div2, div1);
		},
		p(ctx, [dirty]) {
			if (!!/*annotation*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block();
					if_block.c();
					if_block.m(div2, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*annotationTh*/ 0) {
				each_value_6 = annotationTh;
				let i;

				for (i = 0; i < each_value_6.length; i += 1) {
					const child_ctx = get_each_context_6(ctx, each_value_6, i);

					if (each_blocks_6[i]) {
						each_blocks_6[i].p(child_ctx, dirty);
					} else {
						each_blocks_6[i] = create_each_block_6(child_ctx);
						each_blocks_6[i].c();
						each_blocks_6[i].m(tr0, null);
					}
				}

				for (; i < each_blocks_6.length; i += 1) {
					each_blocks_6[i].d(1);
				}

				each_blocks_6.length = each_value_6.length;
			}

			if (dirty & /*annotation*/ 1) {
				each_value_5 = /*annotation*/ ctx[0].default;
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks_5[i]) {
						each_blocks_5[i].p(child_ctx, dirty);
					} else {
						each_blocks_5[i] = create_each_block_5(child_ctx);
						each_blocks_5[i].c();
						each_blocks_5[i].m(tbody0, null);
					}
				}

				for (; i < each_blocks_5.length; i += 1) {
					each_blocks_5[i].d(1);
				}

				each_blocks_5.length = each_value_5.length;
			}

			if (dirty & /*oncoKbTh*/ 0) {
				each_value_4 = oncoKbTh;
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks_4[i]) {
						each_blocks_4[i].p(child_ctx, dirty);
					} else {
						each_blocks_4[i] = create_each_block_4(child_ctx);
						each_blocks_4[i].c();
						each_blocks_4[i].m(tr1, null);
					}
				}

				for (; i < each_blocks_4.length; i += 1) {
					each_blocks_4[i].d(1);
				}

				each_blocks_4.length = each_value_4.length;
			}

			if (dirty & /*annotation*/ 1) {
				each_value_3 = /*annotation*/ ctx[0].oncokb;
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_3(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(tbody1, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_3.length;
			}

			if (dirty & /*oncoKbLevelList*/ 0) {
				each_value_2 = oncoKbLevelList;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_2(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(tbody2, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_2.length;
			}

			if (dirty & /*predictionScoreTh*/ 0) {
				each_value_1 = predictionScoreTh;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(tr2, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*getColor, predictionScore*/ 0) {
				each_value = predictionScore;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block) if_block.d();
			destroy_each(each_blocks_6, detaching);
			destroy_each(each_blocks_5, detaching);
			destroy_each(each_blocks_4, detaching);
			destroy_each(each_blocks_3, detaching);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let annotation;

	setTimeout(
		() => {
			$$invalidate(0, annotation = {
				default: [
					{
						diseases: ["Neuroblastoma 3"],
						index: "clinvar",
						number_of_variants: 0,
						significance: ["Uncertain significance"]
					},
					{
						diseases: [""],
						index: "mgennd",
						number_of_variants: 0,
						significance: [""]
					}
				],
				oncokb: [{ mutation_effect: "", oncogenic: "" }],
				prediction_score: [
					{
						CADD: 0.80477,
						LRT: 0.47681,
						MutationAssessor: 0.25572,
						MutationTaster: 0.81001,
						PROVEAN: 0.74051,
						Polyphen2_HDIV: 0.90584,
						Polyphen2_HVAR: 0.8317,
						PrimateAI: 0.74897,
						REVEL: 0.93266,
						SIFT4G: 0.92824,
						"fathmm-MKL": 0.89172
					}
				]
			});
		},
		1000
	);

	$$invalidate(0, annotation = {
		default: [
			{
				diseases: [],
				index: "",
				number_of_variants: 0,
				significance: []
			},
			{
				diseases: [],
				index: "",
				number_of_variants: 0,
				significance: []
			}
		],
		oncokb: [{ mutation_effect: "", oncogenic: "" }],
		prediction_score: [
			{
				CADD: 0,
				LRT: 0,
				MutationAssessor: 0,
				MutationTaster: 0,
				PROVEAN: 0,
				Polyphen2_HDIV: 0,
				Polyphen2_HVAR: 0,
				PrimateAI: 0,
				REVEL: 0,
				SIFT4G: 0,
				"fathmm-MKL": 0
			}
		]
	});

	return [annotation];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

class AnnotationKeyvalue extends Stanza {
  app = null;

  async render() {
    if (this.app) {
      this.root.querySelector("main > .heatmap-table").remove();
    }
    this.app = new App({
      target: this.root.querySelector("main"),
      props: {
        root: this.root.querySelector("main"),
      },
    });
  }
}

var stanzaModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': AnnotationKeyvalue
});

var metadata = {
	"@context": {
	stanza: "http://togostanza.org/resource/stanza#"
},
	"@id": "annotation-keyvalue",
	"stanza:label": "Annotation Key-Value",
	"stanza:definition": "For PrecisionMD-DB",
	"stanza:license": "MIT",
	"stanza:author": "PENQE",
	"stanza:contributor": [
	"Yukiko Noda"
],
	"stanza:created": "2023-04-06",
	"stanza:updated": "2023-04-06",
	"stanza:parameter": [
],
	"stanza:menu-placement": "none",
	"stanza:style": [
	{
		"stanza:key": "--togostanza-canvas-height",
		"stanza:type": "number",
		"stanza:default": 350,
		"stanza:description": "Canvas height"
	},
	{
		"stanza:key": "--togostanza-theme-background_color",
		"stanza:type": "color",
		"stanza:default": "#11435c",
		"stanza:description": "Background color"
	},
	{
		"stanza:key": "--togostanza-fonts-font_family",
		"stanza:type": "text",
		"stanza:default": "Helvetica Neue, Arial, sans-serif",
		"stanza:description": "Font family"
	},
	{
		"stanza:key": "--togostanza-fonts-font_color",
		"stanza:type": "color",
		"stanza:default": "#ffffff",
		"stanza:description": "Text color"
	},
	{
		"stanza:key": "--togostanza-fonts-font_size_primary",
		"stanza:type": "number",
		"stanza:default": 14,
		"stanza:description": "Primary font size"
	},
	{
		"stanza:key": "--togostanza-fonts-font_align",
		"stanza:type": "single-choice",
		"stanza:choice": [
			"left",
			"center",
			"right"
		],
		"stanza:default": "center",
		"stanza:description": "text align of greeting"
	}
],
	"stanza:incomingEvent": [
],
	"stanza:outgoingEvent": [
]
};

var templates = [
  
];

const url = import.meta.url.replace(/\?.*$/, '');

defineStanzaElement({stanzaModule, metadata, templates, url});
//# sourceMappingURL=annotation-keyvalue.js.map
